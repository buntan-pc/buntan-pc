module top (
  sys_clk: input clock,
  rst_n_raw: input reset_async_low,
  onboard_led: output logic<6>,
  clk_p: output 'dvi clock,
  clk_n: output 'dvi clock,
  data_p: output 'dvi logic[3],
  data_n: output 'dvi logic[3],
) {
  struct DVIParamsSingle {
    bp : u16, // back porch
    act: u16, // active
    fp : u16, // front porch
    syn: u16, // sync
  }
  struct DVIParams {
    h : DVIParamsSingle,
    v : DVIParamsSingle,
  }
  const CVT_RBv2 : DVIParams = DVIParams'{
    h : DVIParamsSingle'{
      bp : 40,
      act: SCRN_W_PIX,
      fp : 8,
      syn: 32,
    },
    v : DVIParamsSingle'{
      bp : 6,
      act: SCRN_H_PIX,
      fp : 4,
      syn: 8,
    },
  };
  const CVT : DVIParams = DVIParams'{
    h : DVIParamsSingle'{
      bp : 128,
      act: SCRN_W_PIX,
      fp : 32,
      syn: 96,
    },
    v : DVIParamsSingle'{
      bp : 8,
      act: SCRN_H_PIX,
      fp : 3,
      syn: 10,
    },
  };

  const DP : DVIParams = CVT_RBv2;

  var rst_n : reset_async_low;
  var dvi_rst_n : 'dvi reset_async_low;

  inst rst_synchronizer: $std::synchronizer_basic #(
    WIDTH: 1,
    STAGES: 2,
  ) (
    i_clk: sys_clk,
    i_rst: rst_n_raw,
    i_d: 1'b1,
    o_d: rst_n,
  );

  assign onboard_led = if rst_n ? ~6'b000101 : '1;

  var fclk : 'dvif clock;
  var pclk : 'dvi clock;
  var pll_lock : 'dvi logic;

  unsafe (cdc) {
    inst pll: $sv::gowin_rpll_fclk(
      clkin: sys_clk,
      clkout: fclk,
      lock: pll_lock
    );

    assign dvi_rst_n = rst_n & pll_lock;

    inst clkdiv: $sv::CLKDIV #(
      DIV_MODE: "5",
      GSREN: "false",
    ) (
      CLKOUT: pclk,
      HCLKIN: fclk,
      RESETN: dvi_rst_n,
      CALIB: 0,
    );

    var data_ser : 'dvi logic[3];
    for i in 0..3 :gen_oser {
      inst data_oser : $sv::OSER10 #(
        GSREN: "false",
        LSREN: "true"
      ) (
        Q: data_ser[i],
        D0: dcb[i].data[0],
        D1: dcb[i].data[1],
        D2: dcb[i].data[2],
        D3: dcb[i].data[3],
        D4: dcb[i].data[4],
        D5: dcb[i].data[5],
        D6: dcb[i].data[6],
        D7: dcb[i].data[7],
        D8: dcb[i].data[8],
        D9: dcb[i].data[9],
        FCLK: fclk,
        PCLK: pclk,
        RESET: ~dvi_rst_n,
      );
    }

    var clk_ser : 'dvi logic;
    inst clk_oser : $sv::OSER10 #(
      GSREN: "false",
      LSREN: "true"
    ) (
      Q: clk_ser,
      D0: 1'b1,
      D1: 1'b1,
      D2: 1'b1,
      D3: 1'b1,
      D4: 1'b1,
      D5: 1'b0,
      D6: 1'b0,
      D7: 1'b0,
      D8: 1'b0,
      D9: 1'b0,
      FCLK: fclk,
      PCLK: pclk,
      RESET: ~dvi_rst_n,
    );
  } // unsafe cdc

  for i in 0..3 :gen_lvds {
    inst lvds_data : $sv::ELVDS_OBUF (
      I: data_ser[i],
      O: data_p[i],
      OB: data_n[i],
    );
  }
  inst lvds_clk : $sv::ELVDS_OBUF (
    I: clk_ser,
    O: clk_p,
    OB: clk_n,
  );

  enum DVIState: bit<2> {
    sync,
    back_porch,
    active,
    front_porch,
  }

  var pixel_h : 'dvi bit<11>; // 0～2047
  var next_pixel_h : 'dvi bit<11>;
  var state_h : 'dvi DVIState;

  var pixel_v : 'dvi bit<10>; // 0～1023
  var state_v : 'dvi DVIState;

  const pixels_per_line : u16 = DP.h.bp + DP.h.act + DP.h.fp + DP.h.syn;
  assign next_pixel_h = if pixel_h <: pixels_per_line - 1 ? pixel_h + 1 : 0;
  assign state_h = switch {
    pixel_h <: DP.h.syn                      : DVIState::sync,
    pixel_h <: DP.h.syn + DP.h.bp            : DVIState::back_porch,
    pixel_h <: DP.h.syn + DP.h.bp + DP.h.act : DVIState::active,
    default                                  : DVIState::front_porch,
  };
  assign state_v = switch {
    pixel_v <: DP.v.syn                      : DVIState::sync,
    pixel_v <: DP.v.syn + DP.v.bp            : DVIState::back_porch,
    pixel_v <: DP.v.syn + DP.v.bp + DP.v.act : DVIState::active,
    default                                  : DVIState::front_porch,
  };

  always_ff (pclk, dvi_rst_n) {
    if_reset {
      pixel_h = 0;
    } else {
      pixel_h = next_pixel_h;
    }
  }
  always_ff (pclk, dvi_rst_n) {
    if_reset {
      pixel_v = 0;
    } else if next_pixel_h == 0 {
      if pixel_v <: DP.v.bp + DP.v.act + DP.v.fp + DP.v.syn - 1 {
        pixel_v += 1;
      } else {
        pixel_v = 0;
      }
    }
  }

  var data_enable : 'dvi bit;
  assign data_enable = state_h == DVIState::active && state_v == DVIState::active;

  function popcnt2(val: input bit<2>) -> u8 {
    return case val {
      2'b00  : 0,
      2'b01  : 1,
      2'b10  : 1,
      default: 2,
    };
  }
  function popcnt4(val: input bit<4>) -> u8 {
    return popcnt2(val[1:0]) + popcnt2(val[3:2]);
  }
  function popcnt8(val: input bit<8>) -> u8 {
    return popcnt4(val[3:0]) + popcnt4(val[7:4]);
  }

  function trans_min(i_data: input bit<8>) -> bit<9> {
    var n1 : u8;
    var is_xnor : bit;
    var o_data : bit<8>;

    n1 = popcnt8(i_data);
    is_xnor = n1 >= 5 || (n1 == 4 && i_data[0] == 0);

    o_data[0] = i_data[0];
    for i: u8 in 0..7 {
      o_data[i+1] = is_xnor ^ (i_data[i+1] ^ o_data[i]);
    }
    return {~is_xnor, o_data};
  }

  struct DCBalancingResult {
    data: bit<10>,
    cnt: i8,
  }
  function balance_dc(data: input bit<9>, cnt: input i8) -> DCBalancingResult {
    var n1 : u8;
    var n0 : u8;
    var n1n0 : i8;

    n1 = popcnt8(data[7:0]);
    n0 = 8 - n1;
    n1n0 = (n1 as i8) - (n0 as i8);

    if cnt == 0 || n1n0 == 0 {
      return DCBalancingResult'{
        data: {~data[8], data[8], if data[8] ? data[7:0] : ~data[7:0]},
        cnt : if data[8] ? cnt + n1n0 : cnt - n1n0,
      };
    } else if (cnt >: 0 && n1n0 >: 0) || (cnt <: 0 && n1n0 <: 0) {
      return DCBalancingResult'{
        data: {1'b1, data[8], ~data[7:0]},
        cnt : cnt + (data[8] << 1) - n1n0,
      };
    } else {
      return DCBalancingResult'{
        data: {1'b0, data[8], data[7:0]},
        cnt : cnt - (data[8] << 1) + n1n0,
      };
    }
  }

  function trans_max(data: input bit<2>) -> bit<10> {
    return case data {
      2'b00  : 10'b0010101011,
      2'b01  : 10'b1101010100,
      2'b10  : 10'b0010101010,
      default: 10'b1101010101,
    };
  }

  const PIXEL_WIDTH: u8 = 10;
  var act_pixel_h : 'dvi bit<PIXEL_WIDTH>;
  var act_pixel_v : 'dvi bit<PIXEL_WIDTH>;
  assign act_pixel_h = pixel_h - DP.h.syn - DP.h.bp;
  assign act_pixel_v = pixel_v - DP.v.syn - DP.v.bp;

  const FONT_W: u8 = 8;
  const FONT_H: u8 = 16;
  const SCRN_W_PIX: u16 = 1024;
  const SCRN_H_PIX: u16 = 600;
  const SCRN_W_CHAR: u16 = SCRN_W_PIX / FONT_W;
  const SCRN_H_CHAR: u16 = SCRN_H_PIX / FONT_H;

  var scrn_mem: 'dvi u8[SCRN_W_CHAR * SCRN_H_CHAR];
  var scrn_buf: 'dvi u8;
  var font_mem: 'dvi bit<FONT_W>[128 * FONT_H];
  var font_buf: 'dvi bit<FONT_W>;

  /* 信号タイミング (WaveDrom)

  {signal: [
    {name: 'pclk',          wave: 'p.......'},
    {name: 'pixel_v',       wave: '=.......', data: ['{m, n}']},
    {name: 'pixel_h[2:0]',  wave: '========', data: [3, 4, 5, 6, 7, 0, 1, 2]},
    {name: '(pixel_h+3)>>3',wave: '=.=.....', data: ['k', 'k+1']},
    {name: 'scrn_addr',     wave: '=.=.....', data: ['128*m+k', '128*m+k+1']},
    {name: 'scrn_mem',      wave: '=..=....', data: ["'A'", "'B'"]},
    {name: 'ld_scrn_buf',   wave: '0..10...'},
    {name: 'scrn_buf',      wave: '=...=...', data: ["'A'", "'B'"]},
    {name: 'font_addr',     wave: '=...=...', data: ["('A'<<4)+n", "('B'<<4)+n"]},
    {name: 'font_mem',      wave: '=....=..', data: ['Aの行n', 'Bの行n']},
  ]}

   */

  var font_xpos: 'dvi bit<$clog2(FONT_W)>;
  var font_ypos: 'dvi bit<$clog2(FONT_H)>;
  assign font_xpos = act_pixel_h[$clog2(FONT_W)-1:0];
  assign font_ypos = act_pixel_v[$clog2(FONT_H)-1:0];

  var scrn_addr: 'dvi bit<PIXEL_WIDTH - 4 + $clog2(SCRN_W_CHAR)>;
  assign scrn_addr =
    (act_pixel_v >> 4) << $clog2(SCRN_W_CHAR)
    | (if state_h == DVIState::back_porch ? 0 : (act_pixel_h + 3) >> $clog2(FONT_W));

  var ld_scrn_buf: 'dvi logic;
  assign ld_scrn_buf = font_xpos == FONT_W - 2;

  var font_addr: 'dvi bit<$clog2(128 * FONT_H)>;
  assign font_addr = scrn_buf << $clog2(FONT_H) | font_ypos;

  always_ff (pclk) {
    font_buf = font_mem[font_addr];
  }

  var pixel_color: 'dvi bit<8>[3];
  assign pixel_color[0] /* B */ = if font_buf[FONT_W - 1 - font_xpos] ? 8'h66 : 8'h00;
  assign pixel_color[1] /* G */ = if font_buf[FONT_W - 1 - font_xpos] ? 8'hFF : 8'h00;
  assign pixel_color[2] /* R */ = 0;

  always_ff (pclk, dvi_rst_n) {
    if_reset {
      scrn_buf = 0;
    } else if ld_scrn_buf {
      scrn_buf = scrn_mem[scrn_addr];
    }
  }

  initial {
    $readmemh("../hankaku.hex", font_mem);
    $readmemh("../scrn_init.hex", scrn_mem);
  }

  var dcb : 'dvi DCBalancingResult[3];
  always_ff (pclk, dvi_rst_n) {
    if_reset {
      for i: u8 in 0..3 {
        dcb[i].cnt = 0;
      }
    } else if data_enable {
      for i: u8 in 0..3 {
        dcb[i] = balance_dc(trans_min(pixel_color[i]), dcb[i].cnt);
      }
    } else {
      dcb[0] = DCBalancingResult'{
        data: trans_max({state_v == DVIState::sync, state_h == DVIState::sync}),
        cnt: 0,
      };
      dcb[1] = DCBalancingResult'{data: trans_max(2'b00), cnt: 0};
      dcb[2] = DCBalancingResult'{data: trans_max(2'b00), cnt: 0};
    }
  }

}

/*
画面制御のパラメタ（CVT-RBv2を採用）

| パラメタ      | CVT   | CVT  | CVT-RB | CVT-RBv2 | Unit   |
| ------------- | ----- | ---- | ------ | -------- | ------ |
| V Frequency   | 59.825| 51.58| 59.695 | 60       | Hz     |
| Pixel Clock   | 49    | 41   | 43.75  | 40.936   | MHz    |
| H Back Porch  | 144   | 128  | 80     | 40       | Pixels |
| H Active      | 1024  | 1024 | 1024   | 1024     | Pixels |
| H Front Porch | 40    | 32   | 48     | 8        | Pixels |
| H Sync        | 104   | 96   | 32     | 32       | Pixels |
| V Back Porch  | 11    | 8    | 6      | 6        | Lines  |
| V Active      | 600   | 600  | 600    | 600      | Lines  |
| V Front Porch | 3     | 3    | 3      | 4        | Lines  |
| V Sync        | 10    | 10   | 10     | 8        | Lines  |
*/
