// SPDX-License-Identifier: MIT
/*
 * Copyright (c) 2026 Kota UCHIDA
 */

module top (
  sys_clk: input clock,
  rst_n_raw: input reset_async_low,
  onboard_led: output logic<6>,
  clk_p: output 'dvi clock,
  clk_n: output 'dvi clock,
  data_p: output 'dvi logic[3],
  data_n: output 'dvi logic[3],
  uart_rx: input  bit,
  uart_tx: output bit,
) {
  struct DVIParamsSingle {
    bp : u16, // back porch
    act: u16, // active
    fp : u16, // front porch
    syn: u16, // sync
  }
  struct DVIParams {
    h : DVIParamsSingle,
    v : DVIParamsSingle,
  }
  const CVT_RBv2 : DVIParams = DVIParams'{
    h : DVIParamsSingle'{
      bp : 40,
      act: SCRN_W_PIX,
      fp : 8,
      syn: 32,
    },
    v : DVIParamsSingle'{
      bp : 6,
      act: SCRN_H_PIX,
      fp : 4,
      syn: 8,
    },
  };
  const CVT : DVIParams = DVIParams'{
    h : DVIParamsSingle'{
      bp : 128,
      act: SCRN_W_PIX,
      fp : 32,
      syn: 96,
    },
    v : DVIParamsSingle'{
      bp : 8,
      act: SCRN_H_PIX,
      fp : 3,
      syn: 10,
    },
  };

  const DP : DVIParams = CVT_RBv2;

  var rst_n : reset_async_low;
  var dvi_rst_n : 'dvi reset_async_low;

  inst rst_synchronizer: $std::synchronizer_basic #(
    WIDTH: 1,
    STAGES: 2,
  ) (
    i_clk: sys_clk,
    i_rst: rst_n_raw,
    i_d: 1'b1,
    o_d: rst_n,
  );

  assign onboard_led = if rst_n ? ~6'b000101 : '1;

  var fclk : 'dvif clock;
  var pclk : 'dvi clock;
  var pll_lock : 'dvi logic;

  unsafe (cdc) {
    inst pll: $sv::gowin_rpll_fclk(
      clkin: sys_clk,
      clkout: fclk,
      lock: pll_lock
    );

    assign dvi_rst_n = rst_n & pll_lock;

    inst clkdiv: $sv::CLKDIV #(
      DIV_MODE: "5",
      GSREN: "false",
    ) (
      CLKOUT: pclk,
      HCLKIN: fclk,
      RESETN: dvi_rst_n,
      CALIB: 0,
    );

    var data_ser : 'dvi logic[3];
    for i in 0..3 :gen_oser {
      inst data_oser : $sv::OSER10 #(
        GSREN: "false",
        LSREN: "true"
      ) (
        Q: data_ser[i],
        D0: dvi_out_data[i][0],
        D1: dvi_out_data[i][1],
        D2: dvi_out_data[i][2],
        D3: dvi_out_data[i][3],
        D4: dvi_out_data[i][4],
        D5: dvi_out_data[i][5],
        D6: dvi_out_data[i][6],
        D7: dvi_out_data[i][7],
        D8: dvi_out_data[i][8],
        D9: dvi_out_data[i][9],
        FCLK: fclk,
        PCLK: pclk,
        RESET: ~dvi_rst_n,
      );
    }

    var clk_ser : 'dvi logic;
    inst clk_oser : $sv::OSER10 #(
      GSREN: "false",
      LSREN: "true"
    ) (
      Q: clk_ser,
      D0: 1'b1,
      D1: 1'b1,
      D2: 1'b1,
      D3: 1'b1,
      D4: 1'b1,
      D5: 1'b0,
      D6: 1'b0,
      D7: 1'b0,
      D8: 1'b0,
      D9: 1'b0,
      FCLK: fclk,
      PCLK: pclk,
      RESET: ~dvi_rst_n,
    );
  } // unsafe cdc

  for i in 0..3 :gen_lvds {
    inst lvds_data : $sv::ELVDS_OBUF (
      I: data_ser[i],
      O: data_p[i],
      OB: data_n[i],
    );
  }
  inst lvds_clk : $sv::ELVDS_OBUF (
    I: clk_ser,
    O: clk_p,
    OB: clk_n,
  );

  enum DVIState: bit<2> {
    sync,
    back_porch,
    active,
    front_porch,
  }

  var pixel_h : 'dvi bit<11>; // 0～2047
  var next_pixel_h : 'dvi bit<11>;
  var state_h : 'dvi DVIState;

  var pixel_v : 'dvi bit<10>; // 0～1023
  var state_v : 'dvi DVIState;

  const pixels_per_line : u16 = DP.h.bp + DP.h.act + DP.h.fp + DP.h.syn;
  assign next_pixel_h = if pixel_h <: pixels_per_line - 1 ? pixel_h + 1 : 0;
  assign state_h = switch {
    pixel_h <: DP.h.syn                      : DVIState::sync,
    pixel_h <: DP.h.syn + DP.h.bp            : DVIState::back_porch,
    pixel_h <: DP.h.syn + DP.h.bp + DP.h.act : DVIState::active,
    default                                  : DVIState::front_porch,
  };
  assign state_v = switch {
    pixel_v <: DP.v.syn                      : DVIState::sync,
    pixel_v <: DP.v.syn + DP.v.bp            : DVIState::back_porch,
    pixel_v <: DP.v.syn + DP.v.bp + DP.v.act : DVIState::active,
    default                                  : DVIState::front_porch,
  };

  always_ff (pclk, dvi_rst_n) {
    if_reset {
      pixel_h = 0;
    } else {
      pixel_h = next_pixel_h;
    }
  }
  always_ff (pclk, dvi_rst_n) {
    if_reset {
      pixel_v = 0;
    } else if next_pixel_h == 0 {
      if pixel_v <: DP.v.bp + DP.v.act + DP.v.fp + DP.v.syn - 1 {
        pixel_v += 1;
      } else {
        pixel_v = 0;
      }
    }
  }

  var data_enable : 'dvi bit;
  assign data_enable = state_h == DVIState::active && state_v == DVIState::active;

  const PIXEL_WIDTH: u8 = 10;
  var act_pixel_h : 'dvi bit<PIXEL_WIDTH>;
  var act_pixel_v : 'dvi bit<PIXEL_WIDTH>;
  assign act_pixel_h = pixel_h - DP.h.syn - DP.h.bp;
  assign act_pixel_v = pixel_v - DP.v.syn - DP.v.bp;

  const FONT_W: u8 = 8;
  const FONT_H: u8 = 16;
  const SCRN_W_PIX: u16 = 1024;
  const SCRN_H_PIX: u16 = 600;
  const SCRN_W_CHAR: u16 = SCRN_W_PIX / FONT_W;
  const SCRN_H_CHAR: u16 = SCRN_H_PIX / FONT_H;

  var scrn_mem: 'dvi u8[SCRN_W_CHAR * SCRN_H_CHAR];
  var scrn_buf: 'dvi u8;
  var font_mem: 'dvi bit<FONT_W>[128 * FONT_H];
  var font_buf: 'dvi bit<FONT_W>;

  /* 信号タイミング (WaveDrom)

  {signal: [
    {name: 'pclk',          wave: 'p.......'},
    {name: 'pixel_v',       wave: '=.......', data: ['{m, n}']},
    {name: 'pixel_h[2:0]',  wave: '========', data: [3, 4, 5, 6, 7, 0, 1, 2]},
    {name: '(pixel_h+3)>>3',wave: '=.=.....', data: ['k', 'k+1']},
    {name: 'scrn_addr',     wave: '=.=.....', data: ['128*m+k', '128*m+k+1']},
    {name: 'scrn_mem',      wave: '=..=....', data: ["'A'", "'B'"]},
    {name: 'ld_scrn_buf',   wave: '0..10...'},
    {name: 'scrn_buf',      wave: '=...=...', data: ["'A'", "'B'"]},
    {name: 'font_addr',     wave: '=...=...', data: ["('A'<<4)+n", "('B'<<4)+n"]},
    {name: 'font_mem',      wave: '=....=..', data: ['Aの行n', 'Bの行n']},
  ]}

   */

  var font_xpos: 'dvi bit<$clog2(FONT_W)>;
  var font_ypos: 'dvi bit<$clog2(FONT_H)>;
  assign font_xpos = act_pixel_h[$clog2(FONT_W)-1:0];
  assign font_ypos = act_pixel_v[$clog2(FONT_H)-1:0];

  var scrn_addr: 'dvi bit<$clog2(SCRN_W_CHAR * SCRN_H_CHAR)>;
  assign scrn_addr =
    (act_pixel_v >> 4) << $clog2(SCRN_W_CHAR)
    | (if state_h == DVIState::back_porch ? 0 : (act_pixel_h + 3) >> $clog2(FONT_W));

  var ld_scrn_buf: 'dvi logic;
  assign ld_scrn_buf = font_xpos == FONT_W - 2;

  var font_addr: 'dvi bit<$clog2(128 * FONT_H)>;
  assign font_addr = scrn_buf << $clog2(FONT_H) | font_ypos;

  always_ff (pclk) {
    font_buf = font_mem[font_addr];
  }

  var pixel_color: 'dvi bit<3, 8>; // B, G, R
  assign pixel_color = if font_buf[FONT_W - 1 - font_xpos] ? 24'h66FF00 : '0;

  always_ff (pclk, dvi_rst_n) {
    if_reset {
      scrn_buf = 0;
    } else if ld_scrn_buf {
      scrn_buf = scrn_mem[scrn_addr];
    }
  }

  var uart_rx_data:  bit<8>;
  var uart_tx_data:  bit<8>;
  var uart_rd:       bit;
  var uart_rx_full:  bit;
  var uart_wr:       bit;
  var uart_tx_ready: bit;
  assign uart_tx_data = 8'hA5;
  assign uart_wr = 0;

  inst uart3b: Uart (
    clk:      sys_clk,
    rst_n:    rst_n,
    rx:       uart_rx,
    tx:       uart_tx,
    rx_data:  uart_rx_data,
    tx_data:  uart_tx_data,
    rd:       uart_rd,
    rx_full:  uart_rx_full,
    wr:       uart_wr,
    tx_ready: uart_tx_ready,
  );

  var uart_rx_full_sync: bit;
  always_ff (sys_clk, rst_n) {
    if_reset {
      uart_rx_full_sync = 0;
    } else {
      uart_rx_full_sync = uart_rx_full;
    }
  }

  var scrn_wr_pos: 'dvi bit<$clog2(SCRN_W_CHAR * SCRN_H_CHAR)>;
  var uart_rx_ack: 'dvi bit;
  var uart_rx_ack_dvi: 'dvi bit; // UART モジュールに対して受信完了を知らせる信号

  unsafe (cdc) {
    always_ff (pclk, dvi_rst_n) {
      if_reset {
        uart_rx_ack = 0;
        scrn_wr_pos = 0;
      } else if uart_rx_full_sync {
        if uart_rx_ack {
          uart_rx_ack_dvi = 1; // 受信後、1クロック経過してから受信完了を通知
        } else {
          uart_rx_ack = 1;
          scrn_mem[scrn_wr_pos] = uart_rx_data; // UART からデータを受信
          scrn_wr_pos += 1;
        }
      } else {
        uart_rx_ack = 0;
        uart_rx_ack_dvi = 0; // uart_rx_full_sync が 0 になったことを確認し、受信完了信号をネゲート
      }
    }
  }

  initial {
    $readmemh("../hankaku.hex", font_mem);
    $readmemh("../scrn_init.hex", scrn_mem);
  }

  var dvi_out_data: 'dvi bit<10>[3];
  inst dvi_out: DviOut (
    clk: pclk,
    rst_n: dvi_rst_n,
    i_color: pixel_color,
    i_de: data_enable,
    i_hsync: state_h == DVIState::sync,
    i_vsync: state_v == DVIState::sync,
    o_data: dvi_out_data,
  );


  var uart_rx_ack_sys: bit;
  unsafe (cdc) {
    assign uart_rx_ack_sys = uart_rx_ack_dvi;
  }

  always_ff (sys_clk, rst_n) {
    if_reset {
      uart_rd = 0;
    } else {
      uart_rd = uart_rx_ack_sys;
    }
  }
}


/*
画面制御のパラメタ（CVT-RBv2を採用）

| パラメタ      | CVT   | CVT  | CVT-RB | CVT-RBv2 | Unit   |
| ------------- | ----- | ---- | ------ | -------- | ------ |
| V Frequency   | 59.825| 51.58| 59.695 | 60       | Hz     |
| Pixel Clock   | 49    | 41   | 43.75  | 40.936   | MHz    |
| H Back Porch  | 144   | 128  | 80     | 40       | Pixels |
| H Active      | 1024  | 1024 | 1024   | 1024     | Pixels |
| H Front Porch | 40    | 32   | 48     | 8        | Pixels |
| H Sync        | 104   | 96   | 32     | 32       | Pixels |
| V Back Porch  | 11    | 8    | 6      | 6        | Lines  |
| V Active      | 600   | 600  | 600    | 600      | Lines  |
| V Front Porch | 3     | 3    | 3      | 4        | Lines  |
| V Sync        | 10    | 10   | 10     | 8        | Lines  |
*/
