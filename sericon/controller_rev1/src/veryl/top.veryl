module top (
  sys_clk: input clock,
  rst_n_raw: input reset_async_low,
  onboard_led: output logic<6>,
  clk_p: output 'dvi clock,
  clk_n: output 'dvi clock,
  data_p: output 'dvi logic[3],
  data_n: output 'dvi logic[3],
  o_state_h: output 'dvi logic<2>,
  o_state_v: output 'dvi logic<2>,
) {
  struct DVIParamsSingle {
    bp : u16, // back porch
    act: u16, // active
    fp : u16, // front porch
    syn: u16, // sync
  }
  struct DVIParams {
    h : DVIParamsSingle,
    v : DVIParamsSingle,
  }
  const CVT_RBv2 : DVIParams = DVIParams'{
    h : DVIParamsSingle'{
      bp : 40,
      act: 1024,
      fp : 8,
      syn: 32,
    },
    v : DVIParamsSingle'{
      bp : 6,
      act: 600,
      fp : 4,
      syn: 8,
    },
  };
  const CVT : DVIParams = DVIParams'{
    h : DVIParamsSingle'{
      bp : 128,
      act: 1024,
      fp : 32,
      syn: 96,
    },
    v : DVIParamsSingle'{
      bp : 8,
      act: 600,
      fp : 3,
      syn: 10,
    },
  };

  const DP : DVIParams = CVT_RBv2;

  var rst_n : reset_async_low;
  var dvi_rst_n : 'dvi reset_async_low;

  inst rst_synchronizer: $std::synchronizer_basic #(
    WIDTH: 1,
    STAGES: 2,
  ) (
    i_clk: sys_clk,
    i_rst: rst_n_raw,
    i_d: 1'b1,
    o_d: rst_n,
  );

  assign onboard_led = if rst_n ? ~6'b000101 : '1;

  var fclk : 'dvi clock;
  var pclk : 'dvi clock;
  var pll_lock : 'dvi logic;

  unsafe (cdc) {
    inst pll: $sv::gowin_rpll_fclk(
      clkin: sys_clk,
      clkout: fclk,
      lock: pll_lock
    );

    assign dvi_rst_n = rst_n & pll_lock;
  }

  inst clkdiv: $sv::CLKDIV #(
    DIV_MODE: "5",
    GSREN: "false",
  ) (
    CLKOUT: pclk,
    HCLKIN: fclk,
    RESETN: dvi_rst_n,
    CALIB: 0,
  );

  enum DVIState: bit<2> {
    sync,
    back_porch,
    active,
    front_porch,
  }

  var pixel_h : 'dvi bit<11>; // 0～2047
  var next_pixel_h : 'dvi bit<11>;
  var state_h : 'dvi DVIState;
  assign o_state_h = state_h;

  var pixel_v : 'dvi bit<10>; // 0～1023
  var state_v : 'dvi DVIState;
  assign o_state_v = state_v;

  const pixels_per_line : u16 = DP.h.bp + DP.h.act + DP.h.fp + DP.h.syn;
  assign next_pixel_h = if pixel_h <: pixels_per_line - 1 ? pixel_h + 1 : 0;
  assign state_h = switch {
    pixel_h <: DP.h.syn                      : DVIState::sync,
    pixel_h <: DP.h.syn + DP.h.bp            : DVIState::back_porch,
    pixel_h <: DP.h.syn + DP.h.bp + DP.h.act : DVIState::active,
    default                                  : DVIState::front_porch,
  };
  assign state_v = switch {
    pixel_v <: DP.v.syn                      : DVIState::sync,
    pixel_v <: DP.v.syn + DP.v.bp            : DVIState::back_porch,
    pixel_v <: DP.v.syn + DP.v.bp + DP.v.act : DVIState::active,
    default                                  : DVIState::front_porch,
  };

  always_ff (pclk, dvi_rst_n) {
    if_reset {
      pixel_h = 0;
    } else {
      pixel_h = next_pixel_h;
    }
  }
  always_ff (pclk, dvi_rst_n) {
    if_reset {
      pixel_v = 0;
    } else if next_pixel_h == 0 {
      if pixel_v <: DP.v.bp + DP.v.act + DP.v.fp + DP.v.syn - 1 {
        pixel_v += 1;
      } else {
        pixel_v = 0;
      }
    }
  }

  var data_enable : 'dvi bit;
  assign data_enable = state_h == DVIState::active && state_v == DVIState::active;

  function popcnt2(val: input bit<2>) -> u8 {
    return case val {
      2'b00  : 0,
      2'b01  : 1,
      2'b10  : 1,
      default: 2,
    };
  }
  function popcnt4(val: input bit<4>) -> u8 {
    return popcnt2(val[1:0]) + popcnt2(val[3:2]);
  }
  function popcnt8(val: input bit<8>) -> u8 {
    return popcnt4(val[3:0]) + popcnt4(val[7:4]);
  }

  function trans_min(i_data: input bit<8>) -> bit<9> {
    var n1 : u8;
    var is_xnor : bit;
    var o_data : bit<8>;

    n1 = popcnt8(i_data);
    is_xnor = n1 >= 5 || (n1 == 4 && i_data[0] == 0);

    o_data[0] = i_data[0];
    for i: u8 in 0..7 {
      o_data[i+1] = is_xnor ^ (i_data[i+1] ^ o_data[i]);
    }
    return {~is_xnor, o_data};
  }

  struct DCBalancingResult {
    data: bit<10>,
    cnt: i8,
  }
  function balance_dc(data: input bit<9>, cnt: input i8) -> DCBalancingResult {
    var n1 : u8;
    var n0 : u8;
    var n1n0 : i8;

    n1 = popcnt8(data[7:0]);
    n0 = 8 - n1;
    n1n0 = (n1 as i8) - (n0 as i8);

    if cnt == 0 || n1n0 == 0 {
      return DCBalancingResult'{
        data: {~data[8], data[8], if data[8] ? data[7:0] : ~data[7:0]},
        cnt : if data[8] ? cnt + n1n0 : cnt - n1n0,
      };
    } else if (cnt >: 0 && n1n0 >: 0) || (cnt <: 0 && n1n0 <: 0) {
      return DCBalancingResult'{
        data: {1'b1, data[8], ~data[7:0]},
        cnt : cnt + (data[8] << 1) - n1n0,
      };
    } else {
      return DCBalancingResult'{
        data: {1'b0, data[8], data[7:0]},
        cnt : cnt - (data[8] << 1) + n1n0,
      };
    }
  }

  function trans_max(data: input bit<2>) -> bit<10> {
    return case data {
      2'b00  : 10'b0010101011,
      2'b01  : 10'b1101010100,
      2'b10  : 10'b0010101010,
      default: 10'b1101010101,
    };
  }

  var act_pixel_h : 'dvi bit<10>;
  var act_pixel_v : 'dvi bit<10>;
  assign act_pixel_h = pixel_h - DP.h.syn - DP.h.bp;
  assign act_pixel_v = pixel_v - DP.v.syn - DP.v.bp;

  // TM(1111_1111) = 0_1111_1111
  // N0 = 0, N1 = 8
  // TM(0000_0000) = 1_0000_0000
  // N0 = 8, N1 = 0
  var dcb : 'dvi DCBalancingResult[2];
  always_ff (pclk, dvi_rst_n) {
    if_reset {
      dcb[0].cnt = 0;
      dcb[1].cnt = 0;
    } else if data_enable {
      dcb[0] = balance_dc(trans_min(act_pixel_h[9:2]), dcb[0].cnt);
      dcb[1] = balance_dc(trans_min(act_pixel_v[7:0]), dcb[1].cnt);
    } else {
      dcb[0] = DCBalancingResult'{
        data: trans_max({state_v == DVIState::sync, state_h == DVIState::sync}),
        cnt: 0,
      };
      dcb[1] = DCBalancingResult'{
        data: trans_max(2'b00),
        cnt: 0,
      };
    }
  }

  var data_ser : 'dvi logic[3];
  for i in 0..3 :gen_oser {
    inst data_oser : $sv::OSER10 #(
      GSREN: "false",
      LSREN: "true"
    ) (
      Q: data_ser[i],
      D0: dcb[if i == 0 ? 0 : 1].data[0],
      D1: dcb[if i == 0 ? 0 : 1].data[1],
      D2: dcb[if i == 0 ? 0 : 1].data[2],
      D3: dcb[if i == 0 ? 0 : 1].data[3],
      D4: dcb[if i == 0 ? 0 : 1].data[4],
      D5: dcb[if i == 0 ? 0 : 1].data[5],
      D6: dcb[if i == 0 ? 0 : 1].data[6],
      D7: dcb[if i == 0 ? 0 : 1].data[7],
      D8: dcb[if i == 0 ? 0 : 1].data[8],
      D9: dcb[if i == 0 ? 0 : 1].data[9],
      FCLK: fclk,
      PCLK: pclk,
      RESET: ~dvi_rst_n,
    );
    inst lvds_data : $sv::ELVDS_OBUF (
      I: data_ser[i],
      O: data_p[i],
      OB: data_n[i],
    );
  }

  var clk_ser : 'dvi logic;
  inst clk_oser : $sv::OSER10 #(
    GSREN: "false",
    LSREN: "true"
  ) (
    Q: clk_ser,
    D0: 1'b1,
    D1: 1'b1,
    D2: 1'b1,
    D3: 1'b1,
    D4: 1'b1,
    D5: 1'b0,
    D6: 1'b0,
    D7: 1'b0,
    D8: 1'b0,
    D9: 1'b0,
    FCLK: fclk,
    PCLK: pclk,
    RESET: ~dvi_rst_n,
  );

  inst lvds_clk : $sv::ELVDS_OBUF (
    I: clk_ser,
    O: clk_p,
    OB: clk_n,
  );
}

/*
画面制御のパラメタ（CVT-RBv2を採用）

| パラメタ      | CVT   | CVT  | CVT-RB | CVT-RBv2 | Unit   |
| ------------- | ----- | ---- | ------ | -------- | ------ |
| V Frequency   | 59.825| 51.58| 59.695 | 60       | Hz     |
| Pixel Clock   | 49    | 41   | 43.75  | 40.936   | MHz    |
| H Back Porch  | 144   | 128  | 80     | 40       | Pixels |
| H Active      | 1024  | 1024 | 1024   | 1024     | Pixels |
| H Front Porch | 40    | 32   | 48     | 8        | Pixels |
| H Sync        | 104   | 96   | 32     | 32       | Pixels |
| V Back Porch  | 11    | 8    | 6      | 6        | Lines  |
| V Active      | 600   | 600  | 600    | 600      | Lines  |
| V Front Porch | 3     | 3    | 3      | 4        | Lines  |
| V Sync        | 10    | 10   | 10     | 8        | Lines  |
*/
